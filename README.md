# python设计模式

## 目标

* 设计模式的应用是为了让程序高内聚，低耦合，高复用，易扩展，易维护。

## 七大原则

### 开闭原则

* 开闭原则（Open Closed Principle，OCP）：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。
* 实现方法：通过接口或抽象类为软件定义稳定的抽象层，相同的可变因素封装在具体的实现类中，从而使软件中易变的细节可以通过从抽象派生一个实现类来扩展。
* 好处：
  * 测试只需要测试扩展的部分；
  * 提高代码的复用性；
  * 稳定性强，易于扩展和维护。

### 里氏替换原则

* 里氏替换原则（Liskov Substitution Principle，LSP）：继承必须确保超类所拥有的性质在子类中仍然成立。
* 实现方法：子类可以扩展父类的功能，但不能改变父类原有的功能，即子类继承父类时，除添加方法完成新增功能外，尽量不要重写父类的方法。
* 好处：
  * 提高父类的可复用性；
  * 类的扩展不会给已有系统引入新的错误，降低代码出错的可能性；
  * 稳定性强，易于扩展和维护。

### 依赖倒置原则

* 依赖倒置原则（Dependence Inversion Principle，DIP）：面向接口编程，而不是面向实现编程，因为细节具有多变性，抽象层相对稳定，以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。
* 实现方法：每个类尽量提供抽象类或接口，或者两者都具备；变量的声明类型尽量是抽象类或接口；任何类都不应该从具体类派生；继承时尽量满足里氏替换原则。
* 好处：降低类之间的耦合；减少并行开发引起的风险；稳定性强，易于扩展和维护。

### 单一职责原则

* 单一职责原则（Single Responsibility Principle，SRP）：职责是指引起类变化的原因，一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。如果一个对象承担了太多的职责，至少存在以下两个缺点：
  * 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
  * 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。
* 实现方法：需要设计人员发现类的不同职责并将其分离，封装到不同的模块或类中。
* 好处：
  * 降低类的复杂度；
  * 提高类的可读性；
  * 变更引起的风险降低；
  * 稳定性强，易于维护。

### 接口隔离原则

* 接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上。
* 接口隔离原则和单一职责原则都是为了提高类的内聚性，降低它们之间的耦合性，体现了封装的思想，但单一职责原则主要是约束类，针对的是程序中的实现细节，接口隔离原则主要是约束接口，主要针对抽象和程序整体框架的构建。
* 实现方法：接口尽量小，一个接口只服务于一个子模块或业务逻辑，用实现多个接口代替实现一个庞大的接口；为依赖接口的类定制服务，只提供调用者需要的方法，屏蔽不需要的方法；提高内聚，减少对外交互，使接口用最少的方法完成最多的事。
* 好处：
  * 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性；
  * 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性；
  * 如果接口的粒度大小定义合理，能够保证系统的稳定性，但如果粒度太小，则会造成接口数量过多，使设计复杂化，如果粒度太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险；
  * 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
  * 减少冗余，过大的大接口里面通常有许多不用的方法，实现这个接口的时候被迫设计冗余的代码。

### 迪米特法则

* 迪米特法则（Low of Demeter，LoD）：又叫最少知识原则（Least Knowledge Principle，LKP），只与你的朋友说话，不和陌生人说话。如果两个软件实体无需直接通信，就不应当发生直接的相互调用，可以通过第三方转发该调用，降低类之间的耦合度，提高模块的独立性。
* 迪米特法则强调以下两点：
  * 从依赖者的角度，只依赖应该依赖的对象；
  * 从被依赖者的角度，只暴露应该暴露的方法。
* 实现方法：
  * 类的划分上，类与类之间的耦合越弱，就越有利于实现可复用的目标；
  * 类的结构设计上，尽量降低类成员的访问权限；
  * 类的设计上，有限考虑将一个类设置成不变类；
  * 对其他类的引用次数降到最低；
  * 不暴露类的属性成员，提供相应的访问器（set和get方法）；
  * 谨慎使用序列化（JAVA的Serializable）功能。
* 好处：
  * 降低了类之间的耦合度，提高了模块的相对独立性，不过过度使用迪米特法则会使系统产生大量的中介类，增加系统复杂性，模块之间的通信效率降低，所以要权衡，确保高内聚低耦合的同时保证系统的结构清晰；
  * 提高了类的可复用性和系统的可扩展性。

### 合成复用原则

* 合成复用原则（Composite Reuse Principle，CRP）：又叫组合/聚合复用原则，优先使用组合或者聚合等关联关系，其次才考虑使用继承关系，使用继承关系时尽量遵循里氏替换原则。
* 实现方法：将已有对象作为新对象的成员纳入，新对象调用已有对象的功能，从而达到复用。
* 继承复用相对合成复用的缺点：
  * 继承复用破坏了类的封装性。子类继承父类时，父类对子类是透明的，是“白箱”复用。
  * 子类和父类耦合度高。父类的变化会引起子类的变化，不利于类的扩展和维护。
  * 限制了复用的灵活性。从父类继承来的实现是静态的，在编译时已经定义，运行时不能发生变化。
* 好处：
  * 维持了类的封装性。因为成分对象的内部细节是新对象看不到的，是“黑箱”复用。
  * 新旧类的耦合度低。新对象调用成分对象的接口，依赖较少。
  * 复用的灵活性高。可以在运行时动态引用与成分对象类型相同的对象。

## 23种设计模式

### 5种创建型模式

* 创建型模式关注如何创建对象，将对象的创建和使用分离：
  * 单例模式（Singleton）
  * 原型模式（Prototype、Cloneable）
  * 简单工厂模式（Factory）
  * 抽象工厂模式（AbstractFactory）
  * 建造者模式（Builder）

### 7种结构型模式

* 结构型模式关注如何将类或对象按某种布局组成更大的结构：
  * 适配器模式（Adapter）
  * 装饰器模式（Decorator）
  * 外观模式（Facade）
  * 代理模式（Proxy）
  * 桥接模式（Bridge）
  * 享元模式（Flyweight）
  * 组合模式（Composite）

### 11种行为型模式

* 行为型模式关注程序在运行时复杂的流程控制，即描述多个类或对象之间如何相互协作完成单个对象无法完成的任务：
  * 责任链模式（Chain of Responsibility）
  * 命令模式（Command）
  * 解释器模式（Interpreter）
  * 迭代器模式（Iterator）
  * 观察者模式（Observer）
  * 状态模式（State）
  * 策略模式（Strategy）
  * 模板方法模式（Template Method）
  * 访问者模式（Visitor）
  * 中介者模式（Mediator）
  * 备忘录模式（Memento）
